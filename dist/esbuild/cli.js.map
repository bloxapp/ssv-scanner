{
  "version": 3,
  "sources": ["../../src/cli-shared.ts", "../../src/commands/Command.ts", "../../src/lib/NonceScanner/NonceScanner.ts", "../../src/lib/contract.provider.ts", "../../src/lib/BaseScanner.ts", "../../src/commands/NonceCommand.ts", "../../src/lib/ClusterScanner/ClusterScanner.ts", "../../src/commands/ClusterCommand.ts", "../../src/cli.ts"],
  "sourcesContent": ["import figlet from 'figlet';\nimport pkg from '../package.json';\nimport { ArgumentParser } from 'argparse';\n\nimport { NonceCommand } from './commands/NonceCommand';\nimport { ClusterCommand } from './commands/ClusterCommand';\n// import { SSVScannerCommand } from './commands/SSVScannerCommand';\n\nconst FigletMessage = async (message: string) => {\n  return new Promise(resolve => {\n    figlet(message, (error: any, output?: string) => {\n      if (error) {\n        return resolve('');\n      }\n      resolve(output);\n    });\n  })\n}\n\nexport default async function main(): Promise<any> {\n  const mainParser = new ArgumentParser();\n  \n  const subparsers = mainParser.add_subparsers({ title: 'commands', dest: 'command' });\n  \n  const clusterCommand = new ClusterCommand();\n  const nonceCommand = new NonceCommand();\n  \n  clusterCommand.setArguments(subparsers.add_parser(clusterCommand.name, { add_help: true }));\n  nonceCommand.setArguments(subparsers.add_parser(nonceCommand.name, { add_help: true }));\n  \n  const messageText = `SSV Scanner v${pkg.version}`;\n  const message = await FigletMessage(messageText);\n  if (message) {\n    console.log(' -----------------------------------------------------------------------------------');\n    console.log(`${message || messageText}`);\n    console.log(' -----------------------------------------------------------------------------------');\n    for (const str of String(pkg.description).match(/.{1,75}/g) || []) {\n      console.log(` ${str}`);\n    }\n    console.log(' -----------------------------------------------------------------------------------\\n');\n  }\n\n  const args = mainParser.parse_args();\n  \n  switch (args.command) {\n    case clusterCommand.name:\n      await clusterCommand.run(args);\n      break;\n    case nonceCommand.name:\n      await nonceCommand.run(args);\n      break;\n    default:\n      console.error('Command not found');\n      process.exit(1);\n  }\n}\n", "import { ArgumentParser } from 'argparse';\n\nexport abstract class Command {\n  protected parser: ArgumentParser;\n\n  constructor(public name: string, protected description: string) {\n    this.parser = new ArgumentParser({ description: this.description });\n    this.setArguments(this.parser);\n  }\n\n  abstract setArguments(parser: ArgumentParser): void;\n\n  parse(args: string[]) {\n    return this.parser.parse_args(args);\n  }\n\n  abstract run(args: any): void;\n}", "\nimport cliProgress from 'cli-progress';\nimport { ContractProvider, ContractVersion } from '../contract.provider';\n\nimport { BaseScanner } from '../BaseScanner';\n\nexport class NonceScanner extends BaseScanner {\n  protected eventsList = [\n    'ValidatorAdded',\n  ];\n\n  async run(cli?: boolean): Promise<number> {\n    if (cli) {\n      console.log('\\nScanning blockchain...');\n      this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);  \n    }\n    try {\n      const data = await this._getLatestNonce(cli);\n      cli && this.progressBar.stop();\n      return data;\n    } catch (e: any) {\n      cli && this.progressBar.stop();\n      throw new Error(e);\n    }\n  }\n\n  private async _getLatestNonce(cli?: boolean): Promise<number> {\n    const [networkEnv, networkGroup] = ContractVersion[this.params.ssvNetwork.toUpperCase() as keyof typeof ContractVersion].split(':');\n    const contractProvider = new ContractProvider(networkEnv, networkGroup, this.params.nodeUrl);\n\n    let latestBlockNumber;\n    try {\n      latestBlockNumber = await contractProvider.web3.eth.getBlockNumber();\n    } catch (err) {\n      throw new Error('Could not access the provided node endpoint.');\n    }\n    try {\n      await contractProvider.contractCore.methods.owner().call();\n    } catch (err) {\n      throw new Error('Could not find any cluster snapshot from the provided contract address.');\n    }\n    let step = this.MONTH;\n    let latestNonce = 0;\n\n    const genesisBlock = contractProvider.genesisBlock;\n    const ownerTopic = contractProvider.web3.eth.abi.encodeParameter('address', this.params.ownerAddress);\n    const filters = {\n      fromBlock: genesisBlock,\n      toBlock: latestBlockNumber,\n      topics: [null, ownerTopic],\n    };\n\n    cli && this.progressBar.start(latestBlockNumber, 0);\n    do {\n      let result: any;\n      try {\n        result = \n          (await contractProvider.contractCore.getPastEvents('AllEvents', filters))\n          .filter((item: any) => this.eventsList.includes(item.event));\n        latestNonce += result.length;\n        filters.fromBlock = filters.toBlock + 1;\n      } catch (e: any) {\n        if (step === this.MONTH) {\n          step = this.WEEK;\n        } else if (step === this.WEEK) {\n          step = this.DAY;\n        } else {\n          throw new Error(e);\n        }\n      }\n      filters.toBlock = Math.min(filters.fromBlock + step, latestBlockNumber);\n      cli && this.progressBar.update(filters.toBlock);\n    } while (filters.toBlock - filters.fromBlock > 0);\n\n    cli && this.progressBar.update(latestBlockNumber, latestBlockNumber);\n\n    return latestNonce;\n  }\n}\n", "import Web3 from 'web3';\n\nexport type NetworkName = string;\nexport type ContractAddress = string;\nexport type ContractData = {\n  version: string;\n  network: string;\n  address: ContractAddress;\n  addressViews: ContractAddress;\n  tokenAddress: string;\n  abi: Record<string, any>;\n  abiViews: Record<string, any>;\n  genesisBlock: number;\n};\n\nexport const ContractVersion = {\n  MAINNET: 'prod:v4.mainnet',\n  PRATER: 'prod:v4.prater',\n  PRATER_STAGE: 'stage:v4.prater',\n} as const;\n\nexport class ContractProvider {\n  private contract: ContractData;\n  public web3: Web3;\n\n  constructor(contractEnv: string, contractGroup: string, nodeUrl: string) {\n\n    let [version, network] = contractGroup.split('.');\n    version = version.toUpperCase();\n    network = network.toUpperCase();\n\n    let jsonCoreData;\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      jsonCoreData = require(`../shared/abi/${contractEnv}.${contractGroup}.abi.json`);\n    } catch (err) {\n      console.error(\n        `Failed to load JSON data from ${contractEnv}.${contractGroup}.abi.json`,\n        err,\n      );\n      throw err;\n    }\n\n    let jsonViewsData;\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      jsonViewsData = require(`../shared/abi/${contractEnv}.${contractGroup}.views.abi.json`);\n    } catch (err) {\n      console.error(\n        `Failed to load JSON data from ${contractEnv}.${contractGroup}.views.abi.json`,\n        err,\n      );\n      throw err;\n    }\n\n    // Check if required properties exist in jsonData\n    if (\n      !jsonCoreData.contractAddress ||\n      !jsonCoreData.abi ||\n      !jsonCoreData.genesisBlock\n    ) {\n      throw new Error(\n        `Missing core data in JSON for ${contractEnv}.${contractGroup}`,\n      );\n    }\n\n    // Check if required properties exist in jsonData\n    if (!jsonViewsData.contractAddress || !jsonViewsData.abi) {\n      throw new Error(\n        `Missing views data in JSON for ${contractEnv}.${contractGroup}`,\n      );\n    }\n\n    this.contract = <ContractData>{\n      version,\n      network,\n      address: jsonCoreData.contractAddress,\n      addressViews: jsonViewsData.contractAddress,\n      abi: jsonCoreData.abi,\n      abiViews: jsonViewsData.abi,\n      genesisBlock: jsonCoreData.genesisBlock,\n    };\n\n    this.web3 = new Web3(nodeUrl);\n  }\n\n  get abiCore() {\n    return this.contract.abi as any;\n  }\n\n  get abiViews() {\n    return this.contract.abiViews as any;\n  }\n\n  get contractCore() {\n    return new this.web3.eth.Contract(this.abiCore, this.contract.address);\n  }\n\n  get contractViews() {\n    return new this.web3.eth.Contract(\n      this.abiViews,\n      this.contract.addressViews,\n    );\n  }\n\n  get genesisBlock() {\n    return this.contract.genesisBlock;\n  }\n}\n", "import Web3 from 'web3';\n\nexport interface SSVScannerParams {\n  ssvNetwork: string,\n  nodeUrl: string,\n  ownerAddress: string,\n  contractAddress: string,\n}\n\nexport abstract class BaseScanner {\n  protected DAY = 5400;\n  protected WEEK = this.DAY * 7;\n  protected MONTH = this.DAY * 30;\n  protected progressBar: any;\n\n  protected params: SSVScannerParams;\n\n  constructor(scannerParams: SSVScannerParams) {\n    if (!scannerParams.nodeUrl) {\n      throw Error('ETH1 node is required');\n    }\n    if (!scannerParams.ssvNetwork) {\n      throw Error('Network is required');\n    }\n    if (!scannerParams.ownerAddress) {\n      throw Error('Cluster owner address is required');\n    }\n    if (scannerParams.ownerAddress.length !== 42) {\n      throw Error('Invalid owner address length.');\n    }\n    if (!scannerParams.ownerAddress.startsWith('0x')) {\n      throw Error('Invalid owner address.');\n    }\n    this.params = scannerParams;\n    // convert to checksum addresses\n    this.params.contractAddress = new Web3().utils.toChecksumAddress(this.params.contractAddress);\n    this.params.ownerAddress = new Web3().utils.toChecksumAddress(this.params.ownerAddress);\n  }\n}", "import { ArgumentParser } from 'argparse';\nimport { Command } from './Command';\nimport { NonceScanner } from '../lib/NonceScanner/NonceScanner';\n\nexport class NonceCommand extends Command {\n  constructor() {\n    super('nonce', 'Handles nonce operations');\n  }\n\n  setArguments(parser: ArgumentParser): void {\n    parser.add_argument('-nw', '--ssv-network', {\n      help: 'The network',\n      choices: ['mainnet', 'prater'],\n      required: true,\n      dest: 'ssvNetwork',\n    });\n    parser.add_argument('-n', '--node-url', {\n      help: `ETH1 (execution client) node endpoint url`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The cluster owner address (in the SSV contract)\",\n      required: true,\n      dest: 'ownerAddress'\n    });    \n  }\n\n  async run(args: any): Promise<void> {\n    try {\n      const nonceScanner = new NonceScanner(args);\n      const result = await nonceScanner.run(true);\n      console.log('Next Nonce:', result);\n    } catch (e: any) {\n      console.error('\\x1b[31m', e.message);\n    }\n  }\n}", "import cliProgress from 'cli-progress';\nimport { ContractProvider, ContractVersion } from '../contract.provider';\n\nimport { BaseScanner } from '../BaseScanner';\n\nexport interface IData {\n  payload: any;\n  cluster: any;\n}\n\nexport class ClusterScanner extends BaseScanner {\n  protected eventsList = [\n    'ClusterDeposited',\n    'ClusterWithdrawn',\n    'ValidatorRemoved',\n    'ValidatorAdded',\n    'ClusterLiquidated',\n    'ClusterReactivated',\n  ]\n\n  async run(operatorIds: number[], cli?: boolean): Promise<IData> {\n    const validOperatorIds = Array.isArray(operatorIds) && this._isValidOperatorIds(operatorIds.length);\n    if (!validOperatorIds) {\n      throw Error('Comma-separated list of operator IDs. The amount must be 3f+1 compatible.');\n    }\n\n    operatorIds = [...operatorIds].sort((a: number, b: number) => a - b);\n\n    if (cli) {\n      console.log('\\nScanning blockchain...');\n      this.progressBar = new cliProgress.SingleBar({}, cliProgress.Presets.shades_classic);  \n    }\n    const data: IData = await this._getClusterSnapshot(operatorIds, cli);\n    cli && this.progressBar.stop();\n    return data;\n  }\n\n  private async _getClusterSnapshot(operatorIds: number[], cli?: boolean): Promise<IData> {\n    let latestBlockNumber;\n    const [networkEnv, networkGroup] = ContractVersion[this.params.ssvNetwork.toUpperCase() as keyof typeof ContractVersion].split(':');\n    const contractProvider = new ContractProvider(networkEnv, networkGroup, this.params.nodeUrl);\n    try {\n      latestBlockNumber = await contractProvider.web3.eth.getBlockNumber();\n    } catch (err) {\n      throw new Error('Could not access the provided node endpoint.');\n    }\n    try {\n      await contractProvider.contractCore.methods.owner().call();\n      // HERE we can validate the contract owner address\n    } catch (err) {\n      console.log(\"eee\", err);\n      throw new Error('Could not find any cluster snapshot from the provided contract address.');\n    }\n    let step = this.MONTH;\n    let clusterSnapshot;\n    let biggestBlockNumber = 0;\n\n    const genesisBlock = contractProvider.genesisBlock;\n    const ownerTopic = contractProvider.web3.eth.abi.encodeParameter('address', this.params.ownerAddress);\n    const filters = {\n      fromBlock: Math.max(latestBlockNumber - step, genesisBlock),\n      toBlock: latestBlockNumber,\n      topics: [null, ownerTopic],\n    };\n\n    cli && this.progressBar.start(latestBlockNumber, 0);\n    while (!clusterSnapshot && filters.fromBlock >= genesisBlock) {\n      let result: any;\n      try {\n        result = await contractProvider.contractCore.getPastEvents('allEvents', filters);\n        result\n          .filter((item: any) => this.eventsList.includes(item.event))\n          .filter((item: any) => JSON.stringify(item.returnValues.operatorIds.map((value: any) => +value)) === JSON.stringify(operatorIds))\n          .forEach((item: any) => {\n            if (item.blockNumber > biggestBlockNumber) {\n              biggestBlockNumber = item.blockNumber;\n              clusterSnapshot = item.returnValues.cluster;\n            }\n          });\n        filters.toBlock = filters.fromBlock;\n      } catch (e) {\n        console.error(e);\n        if (step === this.MONTH) {\n          step = this.WEEK;\n        } else if (step === this.WEEK) {\n          step = this.DAY;\n        }\n      }\n      filters.fromBlock = filters.toBlock - step;\n      cli && this.progressBar.update(latestBlockNumber - (filters.toBlock - step));\n    }\n    cli && this.progressBar.update(latestBlockNumber, latestBlockNumber);\n\n    clusterSnapshot = clusterSnapshot || ['0', '0', '0', true, '0'];\n    return {\n      payload: {\n        'Owner': this.params.ownerAddress,\n        'Operators': operatorIds.sort((a: number, b: number) => a - b).join(','),\n        'Block': biggestBlockNumber || latestBlockNumber,\n        'Data': clusterSnapshot.join(','),\n      },\n      cluster: {\n        validatorCount: clusterSnapshot[0],\n        networkFeeIndex: clusterSnapshot[1],\n        index: clusterSnapshot[2],\n        active: clusterSnapshot[3],\n        balance: clusterSnapshot[4],\n      }\n    };\n  }\n\n  private _isValidOperatorIds(operatorsLength: number) {\n    return (operatorsLength < 4 || operatorsLength > 13 || operatorsLength % 3 != 1) ? false : true;\n  }\n}\n", "import { ArgumentParser } from 'argparse';\nimport { Command } from './Command';\nimport { ClusterScanner } from '../lib/ClusterScanner/ClusterScanner';\n\nexport class ClusterCommand extends Command {\n  constructor() {\n    super('cluster', 'Handles cluster operations');\n  }\n\n  setArguments(parser: ArgumentParser): void {\n    parser.add_argument('-nw', '--ssv-network', {\n      help: 'The network',\n      choices: ['mainnet', 'prater'],\n      required: true,\n      dest: 'ssvNetwork',\n    });\n    parser.add_argument('-n', '--node-url', {\n      help: `ETH1 (execution client) node endpoint url`,\n      required: true,\n      dest: 'nodeUrl'\n    });\n    parser.add_argument('-oa', '--owner-address', {\n      help: \"The cluster owner address (in the SSV contract)\",\n      required: true,\n      dest: 'ownerAddress'\n    });\n    parser.add_argument('-oids', '--operator-ids', {\n      help: `Comma-separated list of operators IDs regarding the cluster that you want to query`,\n      required: true,\n      dest: 'operatorIds'\n    });  \n  }\n\n  async run(args: any): Promise<void> {\n    try {\n      const operatorIds = args.operatorIds.split(',')\n        .map((value: any) => {\n          if (Number.isNaN(+value)) throw new Error('Operator Id should be the number');\n          return +value;\n        })\n        .sort((a: number, b: number) => a - b);\n      const clusterScanner = new ClusterScanner(args);\n      const result = await clusterScanner.run(operatorIds, true);\n      console.table(result.payload);\n      console.log('Cluster snapshot:');\n      console.table(result.cluster);\n      console.log(JSON.stringify({\n        'block': result.payload.Block,\n        'cluster snapshot': result.cluster,\n        'cluster': Object.values(result.cluster)\n      }, null, '  '));\n    } catch (e: any) {\n      console.error('\\x1b[31m', e.message);\n    }\n  }\n}", "#!/usr/bin/env node\n'use strict';\nimport main from './cli-shared';\n\nvoid main();\n"],
  "mappings": "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",
  "names": ["import_figlet", "import_argparse", "import_argparse", "Command", "name", "description", "args", "import_cli_progress", "import_web3", "ContractVersion", "ContractProvider", "contractEnv", "contractGroup", "nodeUrl", "version", "network", "jsonCoreData", "__require", "err", "jsonViewsData", "Web3", "import_web3", "BaseScanner", "scannerParams", "Web3", "NonceScanner", "BaseScanner", "cli", "__async", "cliProgress", "data", "e", "networkEnv", "networkGroup", "ContractVersion", "contractProvider", "ContractProvider", "latestBlockNumber", "err", "step", "latestNonce", "genesisBlock", "ownerTopic", "filters", "result", "item", "NonceCommand", "Command", "parser", "args", "__async", "result", "NonceScanner", "import_cli_progress", "ClusterScanner", "BaseScanner", "operatorIds", "cli", "__async", "a", "b", "cliProgress", "data", "latestBlockNumber", "networkEnv", "networkGroup", "ContractVersion", "contractProvider", "ContractProvider", "err", "step", "clusterSnapshot", "biggestBlockNumber", "genesisBlock", "ownerTopic", "filters", "result", "item", "value", "e", "operatorsLength", "ClusterCommand", "Command", "parser", "args", "__async", "operatorIds", "value", "a", "b", "result", "ClusterScanner", "FigletMessage", "message", "__async", "resolve", "figlet", "error", "output", "main", "mainParser", "subparsers", "clusterCommand", "ClusterCommand", "nonceCommand", "NonceCommand", "messageText", "package_default", "str", "args", "main"]
}
